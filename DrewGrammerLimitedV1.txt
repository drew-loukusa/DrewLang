program         : statement * end!=EOF_TYPE ;
statement       : printstat           
                | blockstat   
                | ifstat      
                | whilestat   
                | assignstat
                | funcdef
                | funccall
                ;

assignstat      : NAME '=' ( expr | funccall ) ';'          ;
printstat       : 'print' '(' ( NAME | expr ) ')' ';'       ;
ifstat          : 'if' '(' test ')' statement               ;
whilestat       : 'while' '(' test ')' statement            ;
blockstat       : '{' statement * end!=RCURBRACK '}'        ;


#expr            : ( NUMBER | string )  add_expr *         end==PLUS,DASH ;
expr            : ( NUMBER | string )  ( add_op expr ) *  end==PLUS,DASH ;
test            : ( NAME | expr ) cmp_op ( NAME | expr )                 ;

funcdef         : 'def' NAME parameters statement  ;
funccall        : NAME parameters ';'                                 ;
parameters      : '(' NAME * end==NAME ( ',' NAME ) * end==COMMA ')' ;

#add_expr        : add_op expr   ;
string          : '"' ( NAME | NUMBER ) * end==NAME,NUMBER '"'     ;
NAME            : ( 'a'..'z' | 'A'..'Z' ) + ;                      
NUMBER          : ('0'..'9') +                                    ;
cmp_op          : DEQUALS | GE | LE | '>' | '<'  ;
add_op          :  '+' | '-'    ;
mult_op         : '*'  | '/'    ;
DEQUALS         : '=' '='       ;
GE              : '>' '='       ;
LE              : '<' '='       ;

#END

# Map rule_name to the token_name that predicts said rule:
PREDICATES: 

printstat -> PRINT              
blockstat -> LCURBRACK
ifstat -> IF
whilestat -> WHILE
funcdef -> DEF
string -> DQUOTE
NAME -> NAME
NUMBER -> NUMBER
DEQUALS -> EQUALS
GE -> GT&EQUALS
LE -> LT&EQUALS
'<' -> LT
'>' -> GT
'+' -> PLUS
'-' -> DASH
'*' -> STAR
'/' -> FSLASH
expr -> NUMBER|DQUOTE
assignstat -> NAME
funccall -> NAME&LPAREN
END
