program      : statement *  ;
statement    : printstat           
             | blockstat   
             | ifstat      
             | whilestat   
             | assignstat
             | funcdef
             | funccall
             ;

assignstat   : NAME '=' ( expr | funccall ) ';'                              ;  ^( '=' expr | funccall )
printstat    : 'print' '(' expr ')' ';'                                      ;  ^( 'print' expr )
ifstat       : 'if' '(' test ')' statement                                   ;  ^( 'if' test statement )
whilestat    : 'while' '(' test ')' statement                                ;  ^( 'while' test statement )
blockstat    : '{' statement * '}'                                           ;  ^( statement ) 

expr         : ( NAME | NUMBER | STRING )  ( add_op expr ) *                 ;  ^(  )
test         : expr cmp_op expr                                              ;

funcdef      : 'def' NAME parameters statement                               ;  ^( 'def' NAME parameters statement )
funccall     : NAME parameters ';'                                           ;  ^( NAME parameters )
parameters   : '(' NAME * ( ',' NAME ) * ')'                                 ;  ^( $params NAME * )
                                                                                # $ is for artificial node 
STRING       : '"' . * end!=" '"'                                            ;  Complete lexical token, returned as node
NAME         : ( 'a'..'z' | 'A'..'Z' )                                       ;  Same as string                
NUMBER       : ('0'..'9')                                                    ;  Same as string
cmp_op       : DEQUALS | GE | LE | '>' | '<'                                 ;  ^( DEQUALS | GE | LE | '>' | '<' )
add_op       :  '+' | '-'                                                    ;  ^( root is anything )
mult_op      : '*'  | '/'                                                    ;  ^( root is anything )
    
DEQUALS      : '=' '='                                                       ; 
GE           : '>' '='                                                       ;
LE           : '<' '='                                                       ;
#LT          : '<'                                                           ;
#GT          : '>'                                                           ;


# Map rule_name to the token_name that predicts said rule:
PREDICATES: 

NAME -> NAME
NUMBER -> NUMBER
GE -> GT&EQUALS
LE -> LT&EQUALS
funccall -> NAME&LPAREN

END

TOKENS: 
#Token Name     Token Text
NAME            multi
NUMBER          multi 
STRING          multi
COMMA           ,
PERIOD          .
LPAREN          ( 
RPAREN          ) 
LCURBRACK       {
RCURBRACK       }   
LBRACK          [
RBRACK          ]
SEMICOLON       ;
COLON           :
EQUALS          =
GT              >
LT              <   
QUOTE           '
DQUOTE          "
STAR            *
PLUS            +
DASH            -
FSLASH          /
BSLASH          \
IF              if 
WHILE           while
PRINT           print
DEF             def
END